## Встроенные структуры данных: продолжение

### List comprehension

В python есть очень удобная и часто используемая на практике
возможность обрабатывать списки в почти-математической нотации.
При этом мы не изменяем старый список, а создаем новый по
определенному правилу. Правила могут быть двух типов:

* можно к каждому элементу применять какое-то действие ---
производить арифметическую операцию или применять какую-то функцию
* можно фильтровать элементы по какому-то правилу, т.е.
логическому выражению. Остаются те элементы, для которых
логическое выражение истинно.

Приведем несколько примеров:

```python
>>> numbers = [1, 4, 2, 7, 4, 9]

# удвоим все элементы:
>>> [x * 2 for x in numbers]
[2, 8, 4, 14, 8, 18]

# создадим список строковых представлений чисел:
>>> [str(item) for item in numbers]
['1', '4', '2', '7', '4', '9']

# оставим только элементы, большие 4:
>>> [n for n in numbers if n > 4]
[7, 9]

# возьмем список слов и приведем к верхнему регистру длинные слова:
>>> words = ['эээ', 'чистая', 'упс', 'ага', 'победа', 'ну', 'ok']
>>> [w.upper() for w in words if len(w) > 3]
['ЧИСТАЯ', 'ПОБЕДА']
```

Как мы видим, list comprehension повторяют некоторые
возможности обработки списков в цикле.
При этом list comprehension короче и яснее
описывает основную идею и немного быстрее работает.
Как правило, стоит в первую очередь стараться использовать их, а
явные циклы оставить для сложных случаев.


### Примеры

#### Задача: найти частотность слов в строке.

Дана строка. Нужно найти для каждого слова, как
часто оно встречалось в этой строке.
Для начала возьмем уже нормализованную строку со словами,
разделенными пробелами.

```python
s = "first second first third second first"

# разбиваем на слова
words = s.split()

# создаем словарь, ключи - слова, значения - частота появления
word_counts = {}

for word in words:
    # если слова нет в словаре, мы сначала его туда добавим
    if word not in word_counts:
        word_counts[word] = 0

    # для каждого найденного слова
    word_counts[word] += 1

# dict.items возвращает пары ключ-значение
for word, count in word_counts.items():
    print(word, count)
```

В отдельном примере в папке можно найти
более реалистичный пример строки, где
сначала её необходимо нормализовать:
почистить от лишних символов и все слова
привести в нижний регистр.
Так же на практике используются т.н. лемматизаторы,
библиотечные функции, которые превращают
слово в его нормальную форму: именительный падеж,
инфинитив и т.п.
Создать такой лемматизатор весьма непросто.
Это большая научно-техническая задача
в компьютерной лингвистике.
С точки зрения же программиста приложений,
подключение лемматизатора лишь добавит еще один
слой обработки, буквально одну строку в код.
Мы пока этого делать не будем.


#### Задача: парсинг простейшего файла конфигурации.

Любое более-менее сложное приложение
обычно использует тот или иной формат конфигурационного файла.
Например, yaml (рекомендуется) или более простой ini.
Подробности можно найти в вашей любимой поисковой системе.

Мы реализуем "парсер" примитивного языка конфигурации, где
вся грамматика может быть описана как множества строк,
содержащих такой паттерн:
```
свойство = значение
```

При этом `значение` может быть числом, и тогда
мы должны это "распарсить" как число. Или оно
может быть просто произвольной строкой.
Пробелы вокруг присваивания опциональны.
Можно попробовать записать эту грамматику в неком подобии нотации БНФ
(форма Бэкуса-Науэра):

```BNF
<присваивание свойства> ::= <имя свойства> [<пробел>] = [<пробел>] <значение>
<значение> ::= <число> | <строка>
```

Функция, которая читает файл, должна возвращать
словарь с ключами-свойствами и соответствующими значениями.

Пусть у нас есть файл `my.cfg` следующего содержания:
```
timeout = 1
env=development
static-path = /var/static
length=1.5
```

Решаем задачу:

```python
## функция, разбирающая одну строку
def get_key_value(line):
    sep = '='

    # разбили строку по символу равенства,
    # ограничив число разбиений до 1
    k, v = [item.strip() for item in line.split(sep, 1)]

    # используем механизм обработки исключений:
    # пробуем (try) сделать что-то потенциально
    # ломающееся и ловим исключение, обрабатывая его.
    # в данном случае обрабатываем исключение
    # ValueError, т.е. ошибку значения.
    # если функция int подавится нашей строкой,
    # она выплевывает именно ValueError.
    try:
        v = int(v)
    except ValueError:
        pass  ## оператор ничего-не-делания

    # возвращаем пару значений.
    return k, v

## функция: принимает имя файла, возвращает словарь конфигурации
def read_cfg(fname):
    cfg = {}

    # читаем файл по-взрослому, с помощью context manager.
    # Этот менеджер контекста сам закроет файл
    # в случае ошибки или просто после прочтения по строкам
    with open(fname) as f:
        for line in f:
            k, v = get_key_value(line)
            cfg[k] = v
    return cfg

## используем наш парсер
print(read_cfg('my.cfg'))
```

В папке примеров пример чуть-чуть дополнен.
В задачах есть упражнения по расширению возможностей этого парсера.
