## Итерации и структуры данных.

### Циклы.

Для организации повторяющихся действий (итераций)
в python можно использовать циклы двух видов: `while` и `for`.

#### Цикл for.
Цикл `for` применяется в том случае, когда мы заранее
знаем (или легко можем вычислить) количество повторений цикла 
и для обхода структур данных:
списков (list), словарей (dict), строк (str), файлов и других.
Цикл `for` в python очень мощный, универсальный и хорошо читаемый.
Если в программе нужны какие-то повторяющиеся действия,
стоит сначала попробовать применить именно его.

Например, выведем таблицу квадратов чисел от 0 до 9:
```python
for i in range(10):
    print(i, i*i)

> 0 0
> 1 1
> 2 4
> 3 9
> 4 16
> 5 25
> 6 36
> 7 49
> 8 64
> 9 81
```

Не вдаваясь пока в детали, заметим, что встроенная 
функция `range` задает переменной цикла (в данном случае `i`)
значения от 0 до заданного параметра, не включая его самого. 
Таким образом `range(10)` позволяет сделать некоторое действие,
определенное в *теле цикла*, 10 раз.

Вычислим, например, *факториал* заданного числа n,
т.е. произведение натуральных чисел от 1 до n включительно:
```python
n = 5
fact = 1
for x in range(n):
    fact *= x + 1
print(fact)

> 120
```

#### Цикл while.

Цикл `while` требуется там, где мы заранее не знаем
количество итераций и вычислить это количество
трудно или вовсе невозможно заранее. А также
во всех других случаях, когда цикл `for` по каким-либо
причинам не годится. В этом цикле действия будут выполняться
до тех пор, *пока* условие цикла *истинно*.

Например, выведем все квадраты натуральных чисел, не превышающие 50:
```python
n = 1
square = 1
while square <= 50:
    print(square)
    n += 1
    square = n * n

> 1
> 4
> 9
> 16
> 25
> 36
> 49
```

Огранизуем бесконечный цикл для взаимодействия с пользователем.
В качестве примера напишем программу, которая выводит
удвоенное введенное число, пока не получит 0 на входе.
Для этого применяем идиому `while True`, т.е. условие цикла
всегда истинно и для выхода из цикла используется оператор
`break` при некотором дополнительном условии.

```python
while True:
    ans = int(input('Введите число, для завершения 0: '))
    if not ans:  ## число 0 считается логической Ложью
        print('До свидания!')
        break
    print(ans, '* 2 =', ans * 2)

> Введите число, для завершения 0: 5
> 5 * 2 = 10
> Введите число, для завершения 0: 9
> 9 * 2 = 18
> Введите число, для завершения 0: 0
> До свидания!
```
Нечто аналогичное мы можем встретить в коде сетевого сервера,
который принимает соединения в бесконечном цикле, и во многих 
других ситуациях.

Большую пользу циклы приносят при обработке структур данных, к
которым мы и переходим.

### Cтруктуры данных.

Мы сейчас обсудим самые базовые возможности.
Для более полного ознакомления с миром встроенных структур данных
python рекомендуется заглянуть в официальную документацию: 
[Data Structures](https://docs.python.org/3/tutorial/datastructures.html)

#### Списки (list).
Можно также почитать документацию:
[Intro to lists](https://docs.python.org/3/tutorial/introduction.html#lists)

То, что в python называется списком, в теории структур данных
чаще зовется *динамическим массивом*. 
Проще говоря, это массив, длина которого может меняться во время работы 
программы. 
Мы будем называть его
массив, list, список, 
считая все это синонимами.
Кроме того, python язык очень гибкий, и в его массиве
могут содержаться элементы разных типов.
Но чаще всего лучше стараться все-таки хранить в массиве
однородные элементы, т.е. элементы одного типа.
Так их проще обрабатывать и проще избегать ошибок.

Итак, приступим. Список чисел:
```python
>>> a = [4, 8, 15, 16, 23, 42]

>>> a[0]  ## индексация начинается с нуля
4

>>> a[-1]  ## последний элемент массива: индексация с конца
42

>>> a[1:4]  ## т.н. срез массива или slice 
[8, 15, 16]

>>> a + [1,2,3]  ## конкатенация, слияние списков
[4, 8, 15, 16, 23, 42, 1, 2, 3]

>>> a[1] = 999  ## элементы массива можно изменять
>>> a
[4, 999, 15, 16, 23, 42]

>>> a.append(273)  ## добавляем элемент в конец массива
>>> a
[4, 999, 15, 16, 23, 42, 273]

>>> a.pop()  ## возвращает последний элемент и убирает его из массива 
273
>>> a
[4, 999, 15, 16, 23, 42]
```

Теперь посмотрим, как цикл `for` справляется с массивами.
```python
## наполним массив квадратами чисел от 1 до N:
N = 4
a = []
for i in range(1, N+1):  ## можно задавать левую и правую границы
    a.append(i * i)    

## выведем массив. Цикл for проходит по всем элементам:
for x in a:
    print(x, end=' ')  ## end определяет как оканчивать вывод вместо
                       ## перевода строки по умолчанию
print()  ## в конце просто переведем строку

>1 4 9 16 
```
