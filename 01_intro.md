## Введение в python.

### Контекст и история.

Язык python изначально был разработан голландским программистом
Гвидо ван Россумом в начале 1990-x годов.
На данный момент история языка насчитывает уже
более 30 лет, половину из которых он устойчиво входит в десятку, а то и
тройку самых популярных языков программирования. 
На момент написания этой заметки, python --- второй по популярности язык.
См. [индекс Tiobe](https://www.tiobe.com/tiobe-index/). 

В наши дни не знать основ python в какой-то степени даже
неприлично. Область применения его чрезвычайно широка:

* обучение основам алгоримов и программирования
* веб-программирование (серверный код и программные клиенты)
* автоматизация рутинных задач
* научные вычисления
* анализ данных и машинное обучение
* тестирование ПО
* сетевые, облачные сервисы
* и так далее...

Python имеет репутацию простого и удобного в использовании, но при этом
очень мощного и достаточно универсального инструмента.
Кроме его удачно спроектированного ядра,
пользователю доступна как обширная стандартная библиотека
(говорят, "батарейки в комплекте")
так и невероятно большое количество 
сторонних библиотек и инструментов.

### Свойства языка.

Рассмотрим некоторые формальные свойства языка.

#### Интерпретируемый
Программный код не требует предварительной
компиляции и сборки в исполняемый файл c машинным кодом.
Программа может быть запущена сразу после ее написания, что
существенно ускоряет и упрощаяет разработку.
Цена за ускоренный запуск --- более медленная 
работа программы. Поэтому среди
применений мы *не находим*

* разработку трехмерных движков высокого класса (хотя как скриптовый язык
он используется и в игровой индустрии)
* высокопроизводительных численных расчетов 
(но подготовка данных, скриптинг, анализ результатов --- 
все это можно и даже нужно делать на python).

Хорошие новости: б*о*льшая часть программ не требуют космических скоростей исполнения,
а удобство написания и поддержки кода важнее. 

#### Динамическая типизация
Типы данных, на которые указывает переменная определяются
автоматически во время работы программы. 
Нам не нужно долго и монотонно
прописывать тип каждой переменной.
Это особенно удобно для быстрого прототипирования, 
небольших скриптов, повседневной автоматизации и 
рассчетов. Но и никакой статической (до запуска программы)
проверки *совместимости типов* мы не имеем.
Груз ответственности за правильное использование типов
ложится на хрупкие плечи разработчика.

Для больших проектов, в которых
участвуют много разработчиков, отсутствие явной информации о типах
не всегда хорошо. Поэтому в python есть т.н. "type hints" ---
необязательные указания типа переменной.
Есть и инструменты статической проверки совместимости типов.

#### Строгая типизация
Несмотря на то, что типы данных указывать явно не нужно,
python строго следит за их совместимостью и не будет
делать каких-то неявных преобразований за
спиной у ничего не подозревающего разработчика.

В *некоторых языках программирования* возможно такое
нелепое смешение строк и чисел:
```javascript
5 + '2' == '52'
5 - '2' == 3
5 * '2' == 10
```
python же на подобные фокусы погрозит пальчиком и 
выбросит исключение (мы позже узнаем, что 
исключение можно *обработать*). Строки к числам и наоборот
нужно преобразовывать *явно* к тому результату, который 
желает увидеть разработчик, а не давать это на откуп 
сумрачному гению, проектирующему за неделю язык программирования.

Примерно вот так:
```python
5 + int('2') == 7
str(5) + '2' == '52'
```
и все счастливы.

### Основные конструкции python.

Для начала будем работать с целыми числами, вводя
по мере развития сюжета и другие типы данных.

#### Арифметика
С числами можно делать совершенно обычные вещи:
```python
>>> 5 + 41
46
>>> 12 * 3
36
>>> 17 - 56
-39
>>> 11 / 5    # обычное деление
2.2
>>> 11 // 2   # целочисленное деление
5
>>> 13 % 5    # останки от деления
3
>>> 5 ** 2    # возводим в квадрат
25
>>> 5 ** 0.5  # извлекаем корень
2.23606797749979
```

Обратите внимание
на различие операторов `//` и `/`. Обычное одинарное деление всегда
имеет своим результатом дробное число (тип float - с плавающей точкой),
двойной же знак деления обозначает деление *целочисленное*.

#### Ввод и вывод
Тема эта крайне обширна. Для начала просто посмотрим 
как можно читать данные
из стандартного потока ввода ("с клавиатуры") и выводить 
в стандартный поток вывода ("на консоль"). Это потребуется нам для 
решения задач. 

Приведем небольшую программу, которая считывает два числа из
двух последовательных строк и выводит их сумму:
```python
# чтение строк
a = input()
b = input()

# преобразование к числам
a = int(a)
b = int(b)

# вычисление суммы
summa = a + b

# вывод
print(summa)
```
Мы видим, что никаких преамбул, вводных и огибающих блоков не нужно. 
Простейшая программа - просто последовательность операторов 
в строках файла.

Для краткости, можно объединить чтение и преобразование:
```python
a = int(input())
```
Тут на вход *функции* `int` поступает результат функции `input`.

#### Условный оператор и логика

Тут впервые на сцену выходит наиболее яркая визуальная 
особенность python: для выделения подчиненных блоков кода
используются лишь отступы, без каких-либо скобочек и бегин-эндов.
Таким образом отступы нужны не только для читабельности кода, но
и напрямую влияют на семантику конструкций.

Пример:
```python
if a > 5:
    print('Больше пяти.')
else:
    print('Не больше пяти.')
```


#### Функции
Функции позволяют нам разбивать задачу на подзадачи,
решать каждую подзадачу по отдельности и 
использовать единожды написанный (и отлаженный!) код
множество раз в самых неожиданных контекстах.
Проще говоря, функции в python - инструмент 
*процедурной абстракции*. Поэтому познакомимся с ними
с самого начала.

```python
def max_number(a, b):
    if a > b:
        return a
    else:
        return b
```

Функция определяется с помощью ключевого слова `def`, что
является сокращением от *define*, т.е., буквально, *определить*.
затем указывается ее имя и *формальные параметры* в скобках.
Ключевое слово `return` позволяет нам вернуть значение в место 
вызова функции. Как видно из примера, return'ов может быть
больше одного. Теоретически, любую функцию можно написать так, чтобы
return был один. Например, так:
```python
def max_number(a, b):
    mn = None
    if a > b:
        mn = a
    else:
        mn = b
    return mn
```
но мы не будем тут придерживаться математической строгости. 
Ограничимся практичностью и будем аккуратны.
