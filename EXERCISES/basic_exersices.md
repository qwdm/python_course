## Базовые задачи.

### Числа.

1. Дано целое число.
    * реализовать встроенные функции bin, hex
    * написать функцию, которая возвращает его представление в n-ичной:
        * n от 2 до 10
        * n от 11 до 36
2. Дана строка, представляющая число в двоичной, десятичной или шестадцатиричной системе счисления.
Написать функцию, которая переводит эту строку в целое число. Т.е. реализовать
часть функциональности встроенной функции `int`.


### Списки.

1. Дан список чисел, найти:
    * сумму всех элементов (реализовать встроенную функцию `sum`)
    * максимальный элемент (реализовать встроенную функцию `max`)
    * среднее арифметическое
    * медианное значение (*указание*: предварительно упорядочить c помощью `mylist.sort()`)
    * количество нулей (реализовать функцию count, которая повторяет функционал соответствующего метода для списков)
2. Дан список слов, найти:
    * самое длинное слово
    * список слов короче N букв
    * 2 списка: слова на гласную и согласную буквы
    * количество уникальных слов
3. Дано 2 упорядоченных списка.
Объединить их в один упорядоченный список.
```python
[1, 5, 9], [2, 5, 13] -> [1, 2, 5, 5, 13]
```
4. Реализовать функцию zip: из пары списков сделать список пар:
```python
zip([1, 2, 3], ['a', 'b', 'c']) -> [(1, 'a'), (2, 'b'), (3, 'c')]
```

### Строки.

1. Дана строка латинских букв.
    * посчитать количество слов в ней
    * превратить в заголовок ('the best' -> 'The Best')
    * заменить все гласные на звездочки (hello -> h\*ll\*)
    * выбросить из нее все слова короче 4 букв

### Словари.

1. Дано 2 списка: ключи и значения. Создать из них словарь.
2. Дано два разных словаря, английские слова в их значения. Объединить их в один словарь.
    * Сначала считать, что слово имеет одно значение.
Если слово встречается в обоих словарях, то "побеждает" значение из второго.
Т.о. нужно реализовать встроенный метод словарей `update` в виде функции `update(Dict, Dict) -> Dict`:
```python
update(
    {'trunk': 'хобот', 'wasted': 'потрачено'}, 
    {'nail': 'гвоздь', 'trunk': 'ствол'}
)
->
{'wasted': 'потрачено', 'nail': 'гвоздь', 'trunk': 'ствол'}
```
    * Затем считать, что слово может иметь множество значений.
Если их несколько, хранить в списке. Пример:
```python
({'trunk': 'хобот', 'wasted': 'потрачено', 'nail': 'ноготь'}, 
 {'nail': 'гвоздь', 'trunk': 'ствол'})
->
{
    'wasted': 'потрачено',
    'nail': ['ноготь', 'гвоздь'],
    'trunk': ['хобот', 'ствол']
}
```

### Практические примеры.

1. Расширить пример чтения конфига из 4 занятия:
    * игнорировать строки комментариев, начинающиеся с символа решетки `#`
    * если значение содержит перечисление элементов через
символ `|`, то разбить элементы и возвратить список, например:
```
names = Вася|Петя|Cаша
```
парсится в
```python
{'names': ['Вася', 'Петя', 'Саша']}
```
    * добавить распознавание значения UUID (см. модуль uuid стандартной
библиотеки)
2. Написать модуль функций чтения и записи csv файла с заголовком,
*не используя* готовых библиотечных решений. Пример файла:
```
name, age, gender
Вася, 23, male
Даша, 19, female
Анамелла, 15, non-binary-trans-person
```
Парсится в список словарей для каждой строчки после заголовка
```python
[
    {'name': 'Вася', 'age': 23, 'gender': 'male'},
    {'name': 'Даша', ...
    ...
]
```
Должна быть возможность выбрать разделитель:
запятая, точка с запятой, символ вертикальной черты `|`, что угодно.

Например, модуль может содержать функции

* read_csv(filename, sep)
* write_csv(list_of_dicts, sep)
